# /bin/shを呼ぶアセンブリ
Linuxのカーネルに対して今のプログラムを放棄し、`/bin/sh`を実行しろと命令するもの。

## システムコールのルールについて
Linuxで何かをするときはカーネルに依頼します。x64 Linuxでは以下のルールが決まっている。
- `RAX` 何をしたいか。59番で`execve`となり、システムでの実行
- `RDI` 第一引数で実行ファイルのパス
- `RSI` 第二引数で実行時の引数リスト
- `RDX` 第三引数で環境変数リスト
x64 Windowsだと以下の通り。
- `EAX/RAX`
- `RCX` 
- `RDX`
- `R8`
これらのレジスタをすべて埋めて`syscall`命令をするのがゴールとなる。

## 命令一覧
- `mov` データのコピー。`mov rdx, 0`で`rdx = 0`と同じ。
- `xor` 排他的論理和。`xor rax, rax`で`\x00`を出さずに0を`RAX`に代入。
- `push` スタックに入れる。 `push rbx`で`RBX`のデータをスタックに入れる。
- `pop` スタックから出す。 `pop rax`でスタックの一番上のデータを`RAX`に入れる。
- `syscall` システムコール。59ならプログラム実行。1なら書き込み。60なら終了。

## Code
```assembly
; 1
xor rdx, rdx
; rdx（第三引数）を0にする。mov rdx, 0としない理由はヌルバイトを使いたくないため。/bin/shで環境変数は特にないため、0にしておく。

; 2
mov rbx, 0x68732f2f6e69622f
; 
; 0x68732f2f6e69622f ASCII変換でhs//nib/となり逆になっている。x86-64 CPUはリトルエンディアンを採用し、逆からレジスタに保存する。
; rbxである理由は特にないが、仮で置いているため邪魔にならないレジスタを選んでいる。

; 3
push rbx
; OSはデータそのものをレジスタで受け取れないため、アドレスで指定したい。前行でrbxに入れたデータをスタックへ入れるとメモリのアドレスができる。

; 4
mov rdi, rsp
; rspは前行のスタックの一番上のアドレスを指しているため、rdiは/bin/shが存在するアドレスを指すことになる。

; 5
push rdx
; 1で作ったrbxの中身（0）をスタックへ入れる。

; 6
push rdi
; （/bin/shのアドレスを指す）rdiをスタックに入れる。
; 5と6で二回pushしているのはC言語のexecveに渡す引数が2つ並んでいなければならないため

; 7
mov rsi, rsp
; rspをrsiにコピー。rsiは/bin/sh, 0と連続で読み込むことになる。

; 8
mov rax, 59
syscall
```

## マシン語への変換
nasmを使用するかpythonのpwntoolsを使用。
```bash
nasm -f elf64 <assemblyファイル> -o shell.o
objdump -d shell.o
```
